# C++

## 头文件

- 头文件要**自给自足**，即不需要为特定场合包含额外头文件

- 头文件要有#define保护：
  
  ```c++
  #ifndef <PROJECT>_<PATH>_<FILE>_H_
  #define <PROJECT>_<PATH>_<FILE>_H_
  ...
  #endif <PROJECT>_<PATH>_<FILE>_H_
  ```

- 不要使用前置声明

- <10行的函数定义成内联，除了析构函数、包含loop和switch、虚函数、递归函数

- 包含头文件使用项目源代码目录（即src之类的）下的路径，不需要使用`.`和`..`
  
  - 例如google-awesome-project/src/base/logging.h的包含方式为
    
    ```C++
    #include "base/logging.h"
    ```

- **头文件包含顺序** 如下，不同类别用空格隔开
  
  > 1. cc文件对应头文件 （优先位置）
  > 2. C 系统文件
  > 3. C++ 系统文件
  > 4. 其他库的 `.h` 文件
  > 5. 本项目内 `.h` 文件
  
  - 这种顺序是为了保证“cc文件对应头文件”遗漏某些必要的库时，cc文件的构建会立刻终止
  
  - 例如
    
    ```C++
    #include "foo/public/fooserver.h" // 优先位置
    
    #include <sys/types.h>
    #include <unistd.h>
    
    #include <hash_map>
    #include <vector>
    
    #include "base/basictypes.h"
    #include "base/commandlineflags.h"
    #include "foo/public/bar.h"
    ```

## 作用域

- 不要使用using指示 和 内联命名空间
  
  - using指示 会污染命名空间
  
  - 内联命名空间 内部的成员不再受其声明所在命名空间的限制 只在大型版本控制里有用
  
  - 匿名命名空间 是 没有名字的命名空间

- 局部变量 置于最小作用域内，并在声明时进行初始化
  
  - 类的声明放在循环外面

## 类

- 构造函数中不要调用虚函数

- 类型转换运算符 和 单参数构造函数 前加上关键词`explicit`以避免隐式类型转换

- 仅当只有数据成员时使用 `struct`，其它一概使用 `class`

- 所有**继承**必须是 `public` 的

- 继承是"is a"，组合是"has a"，优先顺序为：组合 > 实现继承 > 接口继承 > 私有继承

- **继承**主要用于两种场合: 
  
  - 实现继承，子类继承父类的实现代码; 
  
  - [接口继承](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/#interface)，子类仅继承父类的方法名称

- **多重继承** 只能 有一个非抽象类的 基类，其他都是 纯接口类（都是纯虚函数，名称最好以`Interface`结尾）

- 除非意义明显，**不要重载运算符**，虽然会让代码简洁；不要重载 `&&`, `||`, `,` ，`&`， 不要重载 `operator""`（即不要引入[用户自定义字面量后缀](https://zhuanlan.zhihu.com/p/111369693)）

- 将 所有数据成员 声明为 `private`，除非是 `static const` 类型成员

- 将相似的声明放在一起，顺序为`public` 、`protected`、`private` 

## 函数

- 函数体尽量短小，紧凑,，能单一（比如<40行）

- 倾向于按值返回， 否则按引用返回。 避免返回指针， 除非它可以为空

- 函数参数中， 使用 `std::optional` 表示 可选的按值输入

- **输入参数** 是 值参 或 `const` 引用
  
  - 也可以是 `const` 指针, 但决不能是非 `const` 的引用，∵ ①可能传递空指针 ② 把指针或对地址的引用赋值给输入形参

- **输出参数**为指针 （不能用引用？？？）

- 只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致

## 来自 Google 的奇技

- 智能指针是一个通过重载 `*` 和 `->` 运算符以表现得如指针一样的<u>类</u>

- 智能指针类型 被用来自动化 <u>所有权的登记</u>工作

- `std::unique_ptr` 动态分配出的对象的独一无二的所有权，一旦离开作用域就会销毁，不能被复制，但可以move

- `std::shared_ptr` 同样 示动态分配对象的所有权, 但可以被共享, 也可以被复制; 对象的所有权由所有复制者共同拥有, 最后一个复制者被销毁时, 对象也会随着被销毁.

- 不要使用 `std::auto_ptr`，使用 `std::unique_ptr` 代替它

- 使用 `cpplint.py` 检查风格错误

## 其他C++特性

- 尽量使用 **函数重载** 而非 **缺省参数**（即可选参数）。除了以下情况，必须显示提供所有参数
  - 位于 `.cc` 文件里的静态函数或匿名空间函数（∵只能在局部文件里调用该函数）
  - 构造函数（∵不能取得其地址）
  - 模拟变长数组

- 不允许使用变长数组和 `alloca()`，用更安全的分配器（allocator），就像 `std::vector` 或 `std::unique_ptr<T[]>`
- 友元应该定义在同一文件内，其扩大了 (但没有打破) 类的封装边界。优先用友元，而非将 类成员 声明为`public`
- 尽量避免使用 运行时类型识别（RTTI，使用 `typeid` 或者 `dynamic_cast` 完成）
- C++ 的类型转换，例如`static_cast`、`const_cast`和`reinterpret_cast`
- 对于迭代器和其他模板对象 使用`++i`，∵`i++`需要对i进行一次拷贝，代价较大
- 在任何可能的情况下都要使用 `const`，放在 类型 前面
- C++11 里，用 `constexpr`来定义**真正的常量**，或实现常量初始化。
- `<stdint.h> `定义了 `int16_t`, `uint32_t`, `int64_t`等
- 代码应该对 64 位和 32 位系统友好，`printf()`就不友好
- 尽量以内联函数, 枚举和常量代替 **宏**，∵宏 有全局作用域，会导致你和编译器看到的代码是不同的
  - 不要在 `.h` 文件中定义宏

  - 在马上要使用时才进行 `#define`, 使用后要立即 `#undef`
- 初始化，整数用 `0`, 实数用 `0.0`, 指针用 `nullptr` （C++11）或 `NULL`（C++03）, 字符 (串) 用 `'\0'`
- 尽可能用 `sizeof(varname)` 代替 `sizeof(type)`，∵代码中变量类型改变时会自动更新
- 对于局部变量，用 `auto` 绕过烦琐的类型名，只要可读性好就继续用
- C++11 中，任何对象类型都可以被列表初始化，除了用`auto`的
- Lambda不要使用 默认捕获（即`[=]`），所有捕获都要显式写出来（例如`[n]`捕获变量n）
- 不要使用复杂的模板编程吗，只用在少量的基础组件, 基础数据结构上
- 尽量不要让模板对外暴露
- 只使用 Boost 中被认可的库.

## 命名约定

总结示例

```cpp
// 文件名
my_useful_class.cc
// 类型
MyExcitingClass
// 变量 & 结构体变量 & 类成员变量
a_local_variable, a_struct_data_member, a_class_data_member_
// 常量
kDaysInAWeek
// 常规函数
MyExcitingFunction()
// 取值和设值函数
my_exciting_member_variable(), set_my_exciting_member_variable()
// 命名空间
websearch
// 宏（少用）
MY_MACRO_THAT_SCARES_SMALL_CHILDREN
// 枚举
kEnumName, ENUM_NAME
```

- 函数命名、变量命名、文件命名要有描述性，少用 不被大家所知的 缩写

- **文件名**要全部小写，使用`_`（或者`-`），尽量让文件名更加明确

- C++ 文件要以 `.cc` 结尾, 头文件以 `.h` 结尾. 专门插入文本的文件则以 `.inc` 结尾，不要跟 `/usr/include` 下的重名

- **类型名称**的每个单词首字母均大写，无`_`

- **变量** (包括函数参数)  和 数据成员名一律小写, 单词之间用`_`连接；**类的成员变量**以`_`结尾, 但结构体的就不用

- **常量** 命名（声明为 `constexpr` 或 `const`）以 “k” 开头, 大小写混合

- **常规函数** 命名大小写混合（即 “驼峰变量名” 或 “帕斯卡变量名”）

- **取值和设值函数** 与变量名匹配

- **命名空间** 使用小写字母， 最高级命名空间的名字取决于项目名称

- **宏**（少用）使用大写，单词之间用`_`

- **枚举**命名 与 常量 或 宏 一致

- **特例**：如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略

## 注释

- 每一个文件开头加入版权公告（比如许可证引用），文件注释描述了该文件的内容
  
  - 如果你对原始作者的文件做了重大修改, 请考虑删除原作者信息

- 注释避免罗罗嗦嗦, 不要对显而易见的内容进行说明

- 每个类的定义都要附带一份注释, 描述类的功能和用法
  
  ```
  // Iterates over the contents of a GargantuanTable.
  // Example:
  //    GargantuanTableIterator* iter = table->NewIterator();
  //    for (iter->Seek("foo"); !iter->done(); iter->Next()) {
  //      process(iter->key(), iter->value());
  //    }
  //    delete iter;
  class GargantuanTableIterator {
    ...
  };
  ```

- 通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明

- 对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释

- 在行尾注释要空两格，多行注释则要对齐

- 注释不要描述显而易见的现象，永远不要用自然语言翻译代码作为注释，要假设读代码的人c++水平比你高

- 注释的通常写法是包含正确大小写和结尾句号的完整叙述性语句，短一点的注释（比如代码行为注释）可以随意点

- 对那些临时的、短期的解决方案，或已经够好但仍不完美的代码使用TODO注释

## 格式
- 每一行代码字数不超过80，有助于避免代码，可读性失控（比如超多重嵌套、超多重函数调用等）。头文件保护可以
- 无视该规则，包含长路径的#include可以超出
- 缩进使用空格，每次两个
- 尽可能占满每一行，尽量少用空行
- 指针和地址操作符后面，不能有空格
- 类中的public protected private缩进一个空格
- 构造函数初始值列表，如果不能放同一行必须冒号就换行，如果要置于多行则将每一个成员放在单独一行
- 命名空间中的内容不缩进
- 一元操作符和参数之间不加空格

## 规则特例

- 对于现有不符合既定编程风格的代码可以网开一面.
